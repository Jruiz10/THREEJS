<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
  </head>
  <body>

    <script type="module">
      // ============================================================================
      // I find this option simpler than installing the entire three.module.js file
      import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';
      // import * as THREE from '../build/three.module.js';
      // ============================================================================

      let camera, scene, renderer;   // The main three components
      let mesh;

      init();
      animate();

      function init() {
          // Create and set up the camera
	  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
	  camera.position.z = 400;

          // Create and set up the Scene
	  scene = new THREE.Scene();

          const geometry = new THREE.BufferGeometry();
          // create a simple square shape. We duplicate the top left and bottom right
          // vertices because each vertex needs to appear once per triangle.
          const vertices = new Float32Array( [
	      -1.0, -1.0,  1.0,
	      1.0, -1.0,  1.0,
	      1.0,  1.0,  1.0,
              
	      1.0,  1.0,  1.0,
	      -1.0,  1.0,  1.0,
	      -1.0, -1.0,  1.0
          ] );

          // itemSize = 3 because there are 3 values (components) per vertex
          geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
          const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
          mesh = new THREE.Mesh( geometry, material );
          scene.add(mesh);
          mesh.scale.x = 100;
          mesh.scale.y = 100;
          mesh.scale.z = 100;
          
          // var lineGeom = new THREE.BufferGeometry();
          // const vertices = new Float32Array( [
	  //     -2, -2, 0,
          //     2, -2, 0,
          //     0, 2, 0
          // ] );
          // lineGeom.setAttribute('points', new THREE.BufferAttribute(vertices, 3))
          // // lineGeom.vertices.push( new THREE.Vector3(-2,-2,0) );
          // // lineGeom.vertices.push( new THREE.Vector3(2,-2,0) );
          // // lineGeom.vertices.push( new THREE.Vector3(0,2,0) );
          // // lineGeom.colors.push( new THREE.Color(0xff0000) );
          // // lineGeom.colors.push( new THREE.Color(0x00ff00) );
          // // lineGeom.colors.push( new THREE.Color(0x0000ff) );
          // // var lineMat = new THREE.LineBasicMaterial({
          // // linewidth: 3,
          // // vertexColors: THREE.VertexColors
          // // });
          // const lineMat = new THREE.MeshBasicMaterial({color: 0xff0000});
          // var triangle = new THREE.LineLoop( lineGeom, lineMat );
          // scene.add(triangle);  // scene is of type THREE.Scene

          // Create and set up the Renderer
	  renderer = new THREE.WebGLRenderer({ antialias: true });
	  renderer.setPixelRatio(window.devicePixelRatio);
	  renderer.setSize(window.innerWidth, window.innerHeight);
	  document.body.appendChild(renderer.domElement);

	  window.addEventListener( 'resize', onWindowResize );
      }

      // On a window resize, recompute the camera's aspect ratio and then update the project matrix based on that.
      function onWindowResize() {
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();

	  renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
	  requestAnimationFrame(animate);  // Request another call to animation frame (as soon as possible)

          // Rotate the mesh object in the x and y and z directions a bit.
	  // mesh.rotation.x += 0.01;
	  // mesh.rotation.y += 0.01;
	  // mesh.rotation.z += 0.01;

          // And now render the scene using the camera
          //    The renderer does all the set up and calling
	  renderer.render(scene, camera);
      }

    </script>

  </body>
</html>
