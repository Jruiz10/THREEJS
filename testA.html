<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
  </head>
  <body>
    <!-- See main.css for #info and #overlay for the markup attributes for it -->
    <div id="info">Here is a simple example to explore.</div>
    <!-- <div id="overlay">This is an overlay example.</div>  <!-- Uncomment if you want to see an overlay text --> 
    
    <script type="module">
      // ============================================================================
      // I find this option simpler than installing the entire three.module.js file
      import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';
      // import * as THREE from '../build/three.module.js';
      // ============================================================================

      let camera, scene, renderer;   // The main three components
      let mesh;

      init();
      animate();

      function init() {
          // Create and set up the camera
	  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
	  camera.position.z = 400;

          // Create and set up the Scene
	  scene = new THREE.Scene();

          const geometry = new THREE.BufferGeometry();
          // create a simple square shape. We duplicate the top left and bottom right
          // vertices because each vertex needs to appear once per triangle.
          const vertices = new Float32Array( [
	      -1.0, -1.0,  1.0,
	      1.0, -1.0,  1.0,
	      1.0,  1.0,  1.0,
              
	      1.0,  1.0,  1.0,
	      -1.0,  1.0,  1.0,
	      -1.0, -1.0,  1.0
          ] );

          // itemSize = 3 because there are 3 values (components) per vertex
          geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
          const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
          mesh = new THREE.Mesh( geometry, material );
          scene.add(mesh);
          mesh.scale.set(100, 100, 1);

          // Here is an example of BufferGeometry that creates a single triangle
          const points = [];
          points.push(new THREE.Vector3(-1, 0, 1));
          points.push(new THREE.Vector3(1,  0, 1));
          points.push(new THREE.Vector3(0,  1, 1));
          const triangleGeometry = new THREE.BufferGeometry().setFromPoints(points);
          const triangleMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
          const triangleMesh = new THREE.Mesh(triangleGeometry, triangleMaterial)
          scene.add(triangleMesh);
          triangleMesh.scale.set(50, 50, 3);      // Scale it 
          triangleMesh.position.set(0, 80, 0);  // Have its origin position translated to 0,100,0
          
          // Create and set up the Renderer
	  renderer = new THREE.WebGLRenderer({ antialias: true });
	  renderer.setPixelRatio(window.devicePixelRatio);
	  renderer.setSize(window.innerWidth, window.innerHeight);
	  document.body.appendChild(renderer.domElement);

	  window.addEventListener( 'resize', onWindowResize );
      }

      // On a window resize, recompute the camera's aspect ratio and then update the project matrix based on that.
      function onWindowResize() {
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();

	  renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
	  requestAnimationFrame(animate);  // Request another call to animation frame (as soon as possible)

          // Rotate the mesh object in the x and y and z directions a bit.
	  // mesh.rotation.x += 0.01;
	  // mesh.rotation.y += 0.01;
	  // mesh.rotation.z += 0.01;

          // And now render the scene using the camera
          //    The renderer does all the set up and calling
	  renderer.render(scene, camera);
      }

    </script>

  </body>
</html>
