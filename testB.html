<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - geometry - cube</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
  </head>
  <style>
    #blocker {
	position: absolute;
	width: 100%;
	height: 100%;
	background-color: rgba(0,0,0,0.5);
    }
    #instructions {
	width: 100%; height: 100%;
	display: -webkit-box; display: -moz-box; display: box;
        
	-webkit-box-orient: horizontal;	-moz-box-orient: horizontal; box-orient: horizontal;
	-webkit-box-pack: center; -moz-box-pack: center; box-pack: center;
        
	-webkit-box-align: center; -moz-box-align: center; box-align: center;
        
	color: #ffffff;
	text-align: center;
	font-family: Arial;
	font-size: 20px;
	line-height: 30px;
	cursor: pointer;
    }
  </style>
  
  <body>
    <!-- See main.css for #info and #overlay for the markup attributes for it -->
    <div id="info">Do you want to build a Snowman?</div>
    <!-- <div id="overlay">This is an overlay example.</div>  Uncomment if you want to see an overlay text --> 
    <div id="blocker">
      <div id="instructions">
        <span style="font-size:30px">Click to move about</span>
        <br /><br />
        Move: WASD<br/>
        Look: MOUSE
      </div>
    </div>
    
    <script type="module">
      // ============================================================================
      // I find this option simpler than installing the entire three.module.js file
      import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';
      import { PointerLockControls } from './PointerLockControls.js';
      // ============================================================================

      let camera, scene, renderer;   // The main three components
      let controls;                  // The controller for navigation
      let ballMesh;
      let snowman;
      let dz = 0.01;  // How much more the snowman is tilting each iteration
      let floorMesh;
      const FLOOR_WIDTH = 120;  // The dimensions of the floor
      const FLOOR_DEPTH = 120;

      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      let previousAnimationTime = performance.now();

      let moveDirection = new THREE.Vector3();   // The direction to move in camera's view (based on keyboard input)
      let moveSpeed = 5; // Feet per second to move (average walking speed is 4.6 ft/sec)
      
      init();
      animate();

      function init() {
          // Create and set up the camera
	  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
	  camera.position.z = 60;
          camera.position.y = 5.5;

          // Create and set up the Scene
	  scene = new THREE.Scene();

          // A simple snowman
          createSnowman(scene)

          // Create the floor
          createFloor(scene)
          
          // Set up lighting
          setupLighting(scene)

          // Set up the navigation controls
          setupNavigation(scene);
          
          // Create and set up the Renderer
	  renderer = new THREE.WebGLRenderer({ antialias: true });
	  renderer.setPixelRatio(window.devicePixelRatio);
	  renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.shadowMap.enabled = true;   // ADDITION 1: Enable shadow mapping
	  document.body.appendChild(renderer.domElement);

	  window.addEventListener( 'resize', onWindowResize );
      }

      function setupNavigation(parent) {
          controls = new PointerLockControls(camera, document.body);
	  parent.add(controls.getObject());

          // Set up the key listeners
	  const onKeyDown = function (event) {
	      switch (event.code) {
	      case 'ArrowUp':
	      case 'KeyW':
		  moveForward = true;
		  break;

	      case 'ArrowLeft':
	      case 'KeyA':
		  moveLeft = true;
		  break;
                  
	      case 'ArrowDown':
	      case 'KeyS':
		  moveBackward = true;
		  break;
                  
	      case 'ArrowRight':
	      case 'KeyD':
		  moveRight = true;
		  break;

	      }
	  };

	  const onKeyUp = function (event) {
	      switch ( event.code ) {
	      case 'ArrowUp':
	      case 'KeyW':
		  moveForward = false;
		  break;
                  
	      case 'ArrowLeft':
	      case 'KeyA':
		  moveLeft = false;
		  break;
                  
	      case 'ArrowDown':
	      case 'KeyS':
		  moveBackward = false;
		  break;
                  
	      case 'ArrowRight':
	      case 'KeyD':
		  moveRight = false;
		  break;
                  
	      }
	  };

	  document.addEventListener( 'keydown', onKeyDown );
	  document.addEventListener( 'keyup', onKeyUp );

          // Let us grab the Mouse controls from the DOM.
          // We do this using the Pointer Lock API BUT grabbing the pointer is
          // not allowed until user interacts with the program - e.g. via a mouse click.
          // So, we need to set up such a gesture.  Using the PointerLock example from Three.js here.
	  const blocker = document.getElementById('blocker');
	  const instructions = document.getElementById('instructions');
	  instructions.addEventListener('click', function () {
              controls.lock();  // Lock the controls -- REQUESTS that the pointer be locked on this document.
              // The PointerLockControls class handles the mouse motion for looking but not the movement via keyboard controls
              // The lock can only be grabbed IF this event is processed.
	  } );

	  controls.addEventListener('lock', function () {
              // If the lock happens, we can hide the instructions and the blocker
	      instructions.style.display = 'none';
	      blocker.style.display = 'none';
	  } );

	  controls.addEventListener( 'unlock', function () {
	      blocker.style.display = 'block';
	      instructions.style.display = '';
	  } );
      }
      
      function setupLighting(parent) {
          var x;
          for (x = -10; x <= 10; x += 10) {
              var lightColor = 0xcccc99
              // ADDITION 2: PointLight has to be changed to a SpotLight for shadows
              //     Arguments: color, intensity, distance, angle (in radians), penumbra (0 to 1), decay
              var light = new THREE.SpotLight(lightColor, 1, 100, Math.PI/5, 0.4, 1);
              light.position.set(x, 20, 0);

              // ADDITION 3: Need to set up the light's shadow casting properties
              light.castShadow = true;
              light.shadow.mapSize.width = 1024;
              light.shadow.mapSize.height = 1024;
              light.shadow.camera.near = 0.1;   // Units measured in feet (0.1 feet is about 1 inch)
              light.shadow.camera.far = 100;    // Far is about 100 feet away, pretty far for a light
              light.shadow.camera.fov = 30;     // Spotlight angle

              parent.add(light);
              parent.add( new THREE.AmbientLight(0x111100) );
              
              // Make the light "visible"
              // Create the Sphere Geometry
              const geometry = new THREE.SphereGeometry(0.25, 10, 10);
              const mat = new THREE.MeshPhongMaterial( {
                  color: 0x000000,     // reflectivity for diffuse and ambient light
                  emissive: lightColor,  // emission color; a very small amount of red (in case my lighting is not working really)
                  specular: 0x000000,  // reflectivity for specular light
                  shininess: 1       // controls size of specular highlights
              } );
              var lightMesh = new THREE.Mesh( geometry, mat );
              lightMesh.position.set(x, 20, 0);
              parent.add(lightMesh);
          }
      }

      // Create a floor and add it to the parent object
      function createFloor(parent) {
          const marbleTexture = new THREE.TextureLoader().load('textures/white-marble.jpg');
          marbleTexture.repeat = new THREE.Vector2(FLOOR_WIDTH/10, FLOOR_DEPTH/10);  // Repeat the texture in both the width and depth directions
          marbleTexture.wrapS = THREE.MirroredRepeatWrapping;  // When repeating, wrapped but alternate by mirroring (avoids edges)
          marbleTexture.wrapT = THREE.RepeatWrapping;  // Did not use mirror wrapping here, so you can look at the seam that is created. (Perhaps you want it, perhaps not!)
          
          const floor = new THREE.PlaneGeometry(FLOOR_WIDTH, FLOOR_DEPTH, 10*FLOOR_WIDTH, 10*FLOOR_DEPTH);
          // const mat = new THREE.MeshBasicMaterial({ map: marbleTexture});
          const mat = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x010101,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x101010,  // reflectivity for specular light
              shininess: 100,      // controls size of specular highlights
              map: marbleTexture
          } );
          floorMesh = new THREE.Mesh( floor, mat );
          floorMesh.rotation.x = -Math.PI/2;   // Orient it on the floor
          floorMesh.receiveShadow = true;      // ADDITION 4: The floor can RECEIVE shadows (that is, it shows shadows on it)
          parent.add(floorMesh);
      }
      
      function createSnowman(parent) {
          // The holder for our snowman object
          snowman = new THREE.Object3D();

          // Set the material property for the ball
          const snowManMat = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x200000,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x828282,  // reflectivity for specular light
              shininess: 100       // controls size of specular highlights
          } );

          // Create the base of the snowman
          const baseGeometry = new THREE.SphereGeometry(3, 20, 20);
          const midGeometry = new THREE.SphereGeometry(2, 20, 20);
          const headGeometry = new THREE.SphereGeometry(1, 20, 20);

          const baseMesh = new THREE.Mesh(baseGeometry, snowManMat);
          const midMesh = new THREE.Mesh(midGeometry, snowManMat);
          const headMesh = new THREE.Mesh(headGeometry, snowManMat);
          baseMesh.castShadow = true;  // ADDITION 5: The objects in the snowman CASTS shadows.  (We could also have them receive shadows).
          midMesh.castShadow = true;
          headMesh.castShadow = true;
          
          snowman.add(baseMesh);
          baseMesh.position.y = 3;
          snowman.add(midMesh);
          midMesh.position.y = 8;
          snowman.add(headMesh);
          headMesh.position.y = 11;

          snowman.position.z += 5;   // ADDITION 6 (sort of): Moved the snowman forward just a little bit to illustrate shadow more.
          parent.add(snowman);
      }
      
      function createBall(parent) {
          // Create the Sphere Geometry
          const geometry = new THREE.SphereGeometry(50, 20, 20);

          // Set the material property for the ball
          const mat = new THREE.MeshPhongMaterial( {
              color: 0x808080,     // reflectivity for diffuse and ambient light
              emissive: 0x200000,  // emission color; a very small amount of red (in case my lighting is not working really)
              specular: 0x828282,  // reflectivity for specular light
              shininess: 100       // controls size of specular highlights
          } );
          
          // Create the mesh and add it to the scene
          //   We are making the ballMesh global so it can be altered by animation
          ballMesh = new THREE.Mesh( geometry, mat );
          parent.add(ballMesh);

      }

      // On a window resize, recompute the camera's aspect ratio and then update the project matrix based on that.
      function onWindowResize() {
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();

	  renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
	  requestAnimationFrame(animate);  // Request another call to animation frame (as soon as possible)

          // How much time has elapsed since the last animation frame?  (Used for steadier speed)
          const currentTime = performance.now();
          const delta = (currentTime - previousAnimationTime)/1000.0;   // Elapsed time in seconds
          previousAnimationTime = currentTime;

          // Adjust movement (assuming we have locked the mouse pointer to the document)
          if (controls.isLocked) adjustMovement(delta);
                    
          // Rotate the mesh object in the x and y and z directions a bit.
	  snowman.rotation.z += dz;
          if (snowman.rotation.z < -0.5) {
              snowman.rotation.z = -0.5;
              dz = -dz;
          } else if (snowman.rotation.z > 0.5) {
              snowman.rotation.z = 0.5;
              dz = -dz;
          }

          // And now render the scene using the camera
          //    The renderer does all the set up and calling
	  renderer.render(scene, camera);
      }

      // Adjust the camera's position based on keys pressed
      function adjustMovement(delta) {
          // Compute the direction to move based on the WASD keys pressed
          moveDirection.x = Number(moveRight) - Number(moveLeft);  // Since the keyboard allows pushing both at same time (they can cancel each other)
          moveDirection.z = Number(moveForward) - Number(moveBackward);
          moveDirection.normalize();   // Make sure that the direction is of unit length (so diagonal is not faster)

          controls.moveRight(moveDirection.x*moveSpeed*delta);
          controls.moveForward(moveDirection.z*moveSpeed*delta);
      }
    </script>

  </body>
</html>
